#!/usr/bin/env node

/**
 * Type Generation Script
 * Fetches TypeScript types from the backend API and generates a local types file
 */

const fs = require('fs')
const path = require('path')
const https = require('https')
const http = require('http')

// Configuration
const CONFIG = {
  OUTPUT_FILE: path.join(__dirname, '../src/types/generatedTypes.ts'),
  TYPES_ENDPOINT: '/api/types',
  ENV_FILE: path.join(__dirname, '../.env.local'),
}

/**
 * Load environment variables from .env.local
 */
function loadEnvVars() {
  try {
    const envContent = fs.readFileSync(CONFIG.ENV_FILE, 'utf8')
    const envVars = {}

    envContent.split('\n').forEach((line) => {
      const [key, ...valueParts] = line.split('=')
      if (key && valueParts.length > 0) {
        envVars[key.trim()] = valueParts.join('=').trim()
      }
    })

    return envVars
  } catch (error) {
    console.error('‚ùå Error loading environment variables:', error.message)
    process.exit(1)
  }
}

/**
 * Make HTTP/HTTPS request to fetch types
 */
function fetchTypes(url, headers) {
  return new Promise((resolve, reject) => {
    const urlObj = new URL(url)
    const isHttps = urlObj.protocol === 'https:'
    const requestModule = isHttps ? https : http

    const options = {
      hostname: urlObj.hostname,
      port: urlObj.port,
      path: urlObj.pathname,
      method: 'GET',
      headers,
    }

    const req = requestModule.request(options, (res) => {
      let data = ''

      res.on('data', (chunk) => {
        data += chunk
      })

      res.on('end', () => {
        if (res.statusCode >= 200 && res.statusCode < 300) {
          resolve(data)
        } else {
          reject(new Error(`HTTP ${res.statusCode}: ${data}`))
        }
      })
    })

    req.on('error', (error) => {
      reject(error)
    })

    req.setTimeout(10000, () => {
      req.destroy()
      reject(new Error('Request timeout'))
    })

    req.end()
  })
}

/**
 * Ensure output directory exists
 */
function ensureOutputDir() {
  const outputDir = path.dirname(CONFIG.OUTPUT_FILE)
  if (!fs.existsSync(outputDir)) {
    fs.mkdirSync(outputDir, { recursive: true })
    console.log(`üìÅ Created directory: ${outputDir}`)
  }
}

/**
 * Generate types file with additional metadata
 */
function generateTypesFile(typesContent) {
  const header = `/**
 * Generated TypeScript Types from Backend API
 *
 * This file is automatically generated from the backend API.
 * DO NOT EDIT MANUALLY - Changes will be overwritten!
 *
 * To regenerate types, run: npm run generate-types
 * Generated on: ${new Date().toISOString()}
 */

`

  return header + typesContent
}

/**
 * Main execution function
 */
async function main() {
  console.log('üîÑ Starting type generation from backend API...')

  try {
    // Load environment variables
    const envVars = loadEnvVars()
    const apiUrl = envVars.EXPO_PUBLIC_API_URL
    const appKey = envVars.EXPO_PUBLIC_APP_KEY

    if (!apiUrl) {
      throw new Error('EXPO_PUBLIC_API_URL not found in .env.local')
    }

    console.log(`üåê Fetching types from: ${apiUrl}${CONFIG.TYPES_ENDPOINT}`)

    // Prepare headers
    const headers = {
      'Content-Type': 'application/json',
      'User-Agent': 'Vwanu-TypeGenerator/1.0.0',
    }

    if (appKey) {
      headers['x-app-key'] = appKey
    }

    // Fetch types from API
    const typesContent = await fetchTypes(
      apiUrl + CONFIG.TYPES_ENDPOINT,
      headers
    )

    // Ensure output directory exists
    ensureOutputDir()

    // Generate final file content
    const finalContent = generateTypesFile(typesContent)

    // Write to file
    fs.writeFileSync(CONFIG.OUTPUT_FILE, finalContent, 'utf8')

    console.log(`‚úÖ Types successfully generated at: ${CONFIG.OUTPUT_FILE}`)
    console.log(`üìù File size: ${(finalContent.length / 1024).toFixed(2)} KB`)

    // Count exported interfaces/types
    const interfaceCount = (finalContent.match(/export interface/g) || [])
      .length
    const typeCount = (finalContent.match(/export type/g) || []).length
    console.log(
      `üìä Generated ${interfaceCount} interfaces and ${typeCount} type aliases`
    )
  } catch (error) {
    console.error('‚ùå Type generation failed:', error.message)
    process.exit(1)
  }
}

// Handle CLI execution
if (require.main === module) {
  main()
}

module.exports = { main }
